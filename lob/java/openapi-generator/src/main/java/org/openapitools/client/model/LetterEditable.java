/*
 * Lob
 * The Lob API is organized around REST. Our API is designed to have predictable, resource-oriented URLs and uses HTTP response codes to indicate any API errors. <p> 
 *
 * The version of the OpenAPI document: 1.19.18
 * Contact: lob-openapi@lob.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.AddressPlacement;
import org.openapitools.client.model.ExtraService;
import org.openapitools.client.model.InputFromFrom;
import org.openapitools.client.model.InputToTo;
import org.openapitools.client.model.LtrFile;
import org.openapitools.client.model.LtrUseType;
import org.openapitools.client.model.MailType;
import org.openapitools.client.model.QrCode;
import org.openapitools.client.model.ReturnEnvelopeUserProvided;
import org.openapitools.client.model.SendDate;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * LetterEditable
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-11-28T10:58:18.138843-08:00[America/Los_Angeles]")
public class LetterEditable {
  public static final String SERIALIZED_NAME_TO = "to";
  @SerializedName(SERIALIZED_NAME_TO)
  private InputToTo to;

  public static final String SERIALIZED_NAME_FROM = "from";
  @SerializedName(SERIALIZED_NAME_FROM)
  private InputFromFrom from;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Map<String, String> metadata = new HashMap<>();

  public static final String SERIALIZED_NAME_MAIL_TYPE = "mail_type";
  @SerializedName(SERIALIZED_NAME_MAIL_TYPE)
  private MailType mailType = MailType.FIRST_CLASS;

  public static final String SERIALIZED_NAME_MERGE_VARIABLES = "merge_variables";
  @SerializedName(SERIALIZED_NAME_MERGE_VARIABLES)
  private String mergeVariables;

  public static final String SERIALIZED_NAME_SEND_DATE = "send_date";
  @SerializedName(SERIALIZED_NAME_SEND_DATE)
  private SendDate sendDate;

  public static final String SERIALIZED_NAME_FILE = "file";
  @SerializedName(SERIALIZED_NAME_FILE)
  private LtrFile _file;

  public static final String SERIALIZED_NAME_EXTRA_SERVICE = "extra_service";
  @SerializedName(SERIALIZED_NAME_EXTRA_SERVICE)
  private ExtraService extraService;

  public static final String SERIALIZED_NAME_CARDS = "cards";
  @SerializedName(SERIALIZED_NAME_CARDS)
  private List<String> cards;

  public static final String SERIALIZED_NAME_COLOR = "color";
  @SerializedName(SERIALIZED_NAME_COLOR)
  private Boolean color;

  public static final String SERIALIZED_NAME_DOUBLE_SIDED = "double_sided";
  @SerializedName(SERIALIZED_NAME_DOUBLE_SIDED)
  private Boolean doubleSided = true;

  public static final String SERIALIZED_NAME_ADDRESS_PLACEMENT = "address_placement";
  @SerializedName(SERIALIZED_NAME_ADDRESS_PLACEMENT)
  private AddressPlacement addressPlacement = AddressPlacement.TOP_FIRST_PAGE;

  public static final String SERIALIZED_NAME_RETURN_ENVELOPE = "return_envelope";
  @SerializedName(SERIALIZED_NAME_RETURN_ENVELOPE)
  private ReturnEnvelopeUserProvided returnEnvelope = false;

  public static final String SERIALIZED_NAME_PERFORATED_PAGE = "perforated_page";
  @SerializedName(SERIALIZED_NAME_PERFORATED_PAGE)
  private Integer perforatedPage;

  public static final String SERIALIZED_NAME_CUSTOM_ENVELOPE = "custom_envelope";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ENVELOPE)
  private String customEnvelope;

  public static final String SERIALIZED_NAME_BILLING_GROUP_ID = "billing_group_id";
  @SerializedName(SERIALIZED_NAME_BILLING_GROUP_ID)
  private String billingGroupId;

  public static final String SERIALIZED_NAME_QR_CODE = "qr_code";
  @SerializedName(SERIALIZED_NAME_QR_CODE)
  private QrCode qrCode;

  public static final String SERIALIZED_NAME_USE_TYPE = "use_type";
  @SerializedName(SERIALIZED_NAME_USE_TYPE)
  private LtrUseType useType;

  public static final String SERIALIZED_NAME_FSC = "fsc";
  @SerializedName(SERIALIZED_NAME_FSC)
  private Boolean fsc = false;

  public LetterEditable() {
  }

  public LetterEditable to(InputToTo to) {
    
    this.to = to;
    return this;
  }

   /**
   * Get to
   * @return to
  **/
  @javax.annotation.Nonnull
  public InputToTo getTo() {
    return to;
  }


  public void setTo(InputToTo to) {
    this.to = to;
  }


  public LetterEditable from(InputFromFrom from) {
    
    this.from = from;
    return this;
  }

   /**
   * Get from
   * @return from
  **/
  @javax.annotation.Nonnull
  public InputFromFrom getFrom() {
    return from;
  }


  public void setFrom(InputFromFrom from) {
    this.from = from;
  }


  public LetterEditable description(String description) {
    
    this.description = description;
    return this;
  }

   /**
   * An internal description that identifies this resource. Must be no longer than 255 characters. 
   * @return description
  **/
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    this.description = description;
  }


  public LetterEditable metadata(Map<String, String> metadata) {
    
    this.metadata = metadata;
    return this;
  }

  public LetterEditable putMetadataItem(String key, String metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

   /**
   * Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters &#x60;\&quot;&#x60; and &#x60;\\&#x60;. i.e. &#39;{\&quot;customer_id\&quot; : \&quot;NEWYORK2015\&quot;}&#39; Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
   * @return metadata
  **/
  @javax.annotation.Nullable
  public Map<String, String> getMetadata() {
    return metadata;
  }


  public void setMetadata(Map<String, String> metadata) {
    this.metadata = metadata;
  }


  public LetterEditable mailType(MailType mailType) {
    
    this.mailType = mailType;
    return this;
  }

   /**
   * Get mailType
   * @return mailType
  **/
  @javax.annotation.Nullable
  public MailType getMailType() {
    return mailType;
  }


  public void setMailType(MailType mailType) {
    this.mailType = mailType;
  }


  public LetterEditable mergeVariables(String mergeVariables) {
    
    this.mergeVariables = mergeVariables;
    return this;
  }

   /**
   * You can input a merge variable payload object to your template to render dynamic content. For example, if you have a template like: &#x60;{{variable_name}}&#x60;, pass in &#x60;{\&quot;variable_name\&quot;: \&quot;Harry\&quot;}&#x60; to render &#x60;Harry&#x60;. &#x60;merge_variables&#x60; must be an object. Any type of value is accepted as long as the object is valid JSON; you can use &#x60;strings&#x60;, &#x60;numbers&#x60;, &#x60;booleans&#x60;, &#x60;arrays&#x60;, &#x60;objects&#x60;, or &#x60;null&#x60;. The max length of the object is 25,000 characters. If you call &#x60;JSON.stringify&#x60; on your object, it can be no longer than 25,000 characters. Your variable names cannot contain any whitespace or any of the following special characters: &#x60;!&#x60;, &#x60;\&quot;&#x60;, &#x60;#&#x60;, &#x60;%&#x60;, &#x60;&amp;&#x60;, &#x60;&#39;&#x60;, &#x60;(&#x60;, &#x60;)&#x60;, &#x60;*&#x60;, &#x60;+&#x60;, &#x60;,&#x60;, &#x60;/&#x60;, &#x60;;&#x60;, &#x60;&lt;&#x60;, &#x60;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;@&#x60;, &#x60;[&#x60;, &#x60;\\&#x60;, &#x60;]&#x60;, &#x60;^&#x60;, &#x60;&#x60; &#x60; &#x60;&#x60;, &#x60;{&#x60;, &#x60;|&#x60;, &#x60;}&#x60;, &#x60;~&#x60;. More instructions can be found in &lt;a href&#x3D;\&quot;https://help.lob.com/print-and-mail/designing-mail-creatives/dynamic-personalization#using-html-and-merge-variables-10\&quot; target&#x3D;\&quot;_blank\&quot;&gt;our guide to using html and merge variables&lt;/a&gt;. Depending on your &lt;a href&#x3D;\&quot;https://dashboard.lob.com/#/settings/account\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Merge Variable strictness&lt;/a&gt; setting, if you define variables in your HTML but do not pass them here, you will either receive an error or the variable will render as an empty string.
   * @return mergeVariables
  **/
  @javax.annotation.Nullable
  public String getMergeVariables() {
    return mergeVariables;
  }


  public void setMergeVariables(String mergeVariables) {
    this.mergeVariables = mergeVariables;
  }


  public LetterEditable sendDate(SendDate sendDate) {
    
    this.sendDate = sendDate;
    return this;
  }

   /**
   * Get sendDate
   * @return sendDate
  **/
  @javax.annotation.Nullable
  public SendDate getSendDate() {
    return sendDate;
  }


  public void setSendDate(SendDate sendDate) {
    this.sendDate = sendDate;
  }


  public LetterEditable _file(LtrFile _file) {
    
    this._file = _file;
    return this;
  }

   /**
   * Get _file
   * @return _file
  **/
  @javax.annotation.Nonnull
  public LtrFile getFile() {
    return _file;
  }


  public void setFile(LtrFile _file) {
    this._file = _file;
  }


  public LetterEditable extraService(ExtraService extraService) {
    
    this.extraService = extraService;
    return this;
  }

   /**
   * Get extraService
   * @return extraService
  **/
  @javax.annotation.Nullable
  public ExtraService getExtraService() {
    return extraService;
  }


  public void setExtraService(ExtraService extraService) {
    this.extraService = extraService;
  }


  public LetterEditable cards(List<String> cards) {
    
    this.cards = cards;
    return this;
  }

  public LetterEditable addCardsItem(String cardsItem) {
    if (this.cards == null) {
      this.cards = new ArrayList<>();
    }
    this.cards.add(cardsItem);
    return this;
  }

   /**
   * A single-element array containing an existing card id in a string format. See [cards](#tag/Cards) for more information.
   * @return cards
  **/
  @javax.annotation.Nullable
  public List<String> getCards() {
    return cards;
  }


  public void setCards(List<String> cards) {
    this.cards = cards;
  }


  public LetterEditable color(Boolean color) {
    
    this.color = color;
    return this;
  }

   /**
   * Get color
   * @return color
  **/
  @javax.annotation.Nonnull
  public Boolean getColor() {
    return color;
  }


  public void setColor(Boolean color) {
    this.color = color;
  }


  public LetterEditable doubleSided(Boolean doubleSided) {
    
    this.doubleSided = doubleSided;
    return this;
  }

   /**
   * Set this attribute to &#x60;true&#x60; for double sided printing, or &#x60;false&#x60; for for single sided printing. Defaults to &#x60;true&#x60;.
   * @return doubleSided
  **/
  @javax.annotation.Nullable
  public Boolean getDoubleSided() {
    return doubleSided;
  }


  public void setDoubleSided(Boolean doubleSided) {
    this.doubleSided = doubleSided;
  }


  public LetterEditable addressPlacement(AddressPlacement addressPlacement) {
    
    this.addressPlacement = addressPlacement;
    return this;
  }

   /**
   * Get addressPlacement
   * @return addressPlacement
  **/
  @javax.annotation.Nullable
  public AddressPlacement getAddressPlacement() {
    return addressPlacement;
  }


  public void setAddressPlacement(AddressPlacement addressPlacement) {
    this.addressPlacement = addressPlacement;
  }


  public LetterEditable returnEnvelope(ReturnEnvelopeUserProvided returnEnvelope) {
    
    this.returnEnvelope = returnEnvelope;
    return this;
  }

   /**
   * Get returnEnvelope
   * @return returnEnvelope
  **/
  @javax.annotation.Nullable
  public ReturnEnvelopeUserProvided getReturnEnvelope() {
    return returnEnvelope;
  }


  public void setReturnEnvelope(ReturnEnvelopeUserProvided returnEnvelope) {
    this.returnEnvelope = returnEnvelope;
  }


  public LetterEditable perforatedPage(Integer perforatedPage) {
    
    this.perforatedPage = perforatedPage;
    return this;
  }

   /**
   * Required if &#x60;return_envelope&#x60; is &#x60;true&#x60;. The number of the page that should be perforated for use with the return envelope. Must be greater than or equal to &#x60;1&#x60;. The blank page added by &#x60;address_placement&#x3D;insert_blank_page&#x60; will be ignored when considering the perforated page number. To see how perforation will impact your letter design, view our &lt;a href&#x3D;\&quot;https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_perf_template.pdf\&quot; target&#x3D;\&quot;_blank\&quot;&gt;perforation guide&lt;/a&gt;.
   * @return perforatedPage
  **/
  @javax.annotation.Nullable
  public Integer getPerforatedPage() {
    return perforatedPage;
  }


  public void setPerforatedPage(Integer perforatedPage) {
    this.perforatedPage = perforatedPage;
  }


  public LetterEditable customEnvelope(String customEnvelope) {
    
    this.customEnvelope = customEnvelope;
    return this;
  }

   /**
   * Accepts an envelope ID for any customized envelope with available inventory. If no inventory is available for the specified ID, the letter will not be sent, and an error will be returned. If the letter has more than 6 sheets, it will be sent in a blank flat envelope. Custom envelopes may be created and ordered from the dashboard. This feature is exclusive to certain customers. Upgrade to the appropriate &lt;a href&#x3D;\&quot;https://dashboard.lob.com/#/settings/editions\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Print &amp; Mail Edition&lt;/a&gt; to gain access.
   * @return customEnvelope
  **/
  @javax.annotation.Nullable
  public String getCustomEnvelope() {
    return customEnvelope;
  }


  public void setCustomEnvelope(String customEnvelope) {
    this.customEnvelope = customEnvelope;
  }


  public LetterEditable billingGroupId(String billingGroupId) {
    
    this.billingGroupId = billingGroupId;
    return this;
  }

   /**
   * An optional string with the billing group ID to tag your usage with. Is used for billing purposes. Requires special activation to use. See &lt;a href&#x3D;\&quot;#tag/Billing-Groups\&quot;&gt;Billing Group API&lt;/a&gt; for more information.
   * @return billingGroupId
  **/
  @javax.annotation.Nullable
  public String getBillingGroupId() {
    return billingGroupId;
  }


  public void setBillingGroupId(String billingGroupId) {
    this.billingGroupId = billingGroupId;
  }


  public LetterEditable qrCode(QrCode qrCode) {
    
    this.qrCode = qrCode;
    return this;
  }

   /**
   * Get qrCode
   * @return qrCode
  **/
  @javax.annotation.Nullable
  public QrCode getQrCode() {
    return qrCode;
  }


  public void setQrCode(QrCode qrCode) {
    this.qrCode = qrCode;
  }


  public LetterEditable useType(LtrUseType useType) {
    
    this.useType = useType;
    return this;
  }

   /**
   * Get useType
   * @return useType
  **/
  @javax.annotation.Nullable
  public LtrUseType getUseType() {
    return useType;
  }


  public void setUseType(LtrUseType useType) {
    this.useType = useType;
  }


  public LetterEditable fsc(Boolean fsc) {
    
    this.fsc = fsc;
    return this;
  }

   /**
   * This is in beta. Contact support@lob.com or your account contact to learn more. Not available for &#x60;A4&#x60; letter size.
   * @return fsc
  **/
  @javax.annotation.Nullable
  public Boolean getFsc() {
    return fsc;
  }


  public void setFsc(Boolean fsc) {
    this.fsc = fsc;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LetterEditable letterEditable = (LetterEditable) o;
    return Objects.equals(this.to, letterEditable.to) &&
        Objects.equals(this.from, letterEditable.from) &&
        Objects.equals(this.description, letterEditable.description) &&
        Objects.equals(this.metadata, letterEditable.metadata) &&
        Objects.equals(this.mailType, letterEditable.mailType) &&
        Objects.equals(this.mergeVariables, letterEditable.mergeVariables) &&
        Objects.equals(this.sendDate, letterEditable.sendDate) &&
        Objects.equals(this._file, letterEditable._file) &&
        Objects.equals(this.extraService, letterEditable.extraService) &&
        Objects.equals(this.cards, letterEditable.cards) &&
        Objects.equals(this.color, letterEditable.color) &&
        Objects.equals(this.doubleSided, letterEditable.doubleSided) &&
        Objects.equals(this.addressPlacement, letterEditable.addressPlacement) &&
        Objects.equals(this.returnEnvelope, letterEditable.returnEnvelope) &&
        Objects.equals(this.perforatedPage, letterEditable.perforatedPage) &&
        Objects.equals(this.customEnvelope, letterEditable.customEnvelope) &&
        Objects.equals(this.billingGroupId, letterEditable.billingGroupId) &&
        Objects.equals(this.qrCode, letterEditable.qrCode) &&
        Objects.equals(this.useType, letterEditable.useType) &&
        Objects.equals(this.fsc, letterEditable.fsc);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(to, from, description, metadata, mailType, mergeVariables, sendDate, _file, extraService, cards, color, doubleSided, addressPlacement, returnEnvelope, perforatedPage, customEnvelope, billingGroupId, qrCode, useType, fsc);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LetterEditable {\n");
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    mailType: ").append(toIndentedString(mailType)).append("\n");
    sb.append("    mergeVariables: ").append(toIndentedString(mergeVariables)).append("\n");
    sb.append("    sendDate: ").append(toIndentedString(sendDate)).append("\n");
    sb.append("    _file: ").append(toIndentedString(_file)).append("\n");
    sb.append("    extraService: ").append(toIndentedString(extraService)).append("\n");
    sb.append("    cards: ").append(toIndentedString(cards)).append("\n");
    sb.append("    color: ").append(toIndentedString(color)).append("\n");
    sb.append("    doubleSided: ").append(toIndentedString(doubleSided)).append("\n");
    sb.append("    addressPlacement: ").append(toIndentedString(addressPlacement)).append("\n");
    sb.append("    returnEnvelope: ").append(toIndentedString(returnEnvelope)).append("\n");
    sb.append("    perforatedPage: ").append(toIndentedString(perforatedPage)).append("\n");
    sb.append("    customEnvelope: ").append(toIndentedString(customEnvelope)).append("\n");
    sb.append("    billingGroupId: ").append(toIndentedString(billingGroupId)).append("\n");
    sb.append("    qrCode: ").append(toIndentedString(qrCode)).append("\n");
    sb.append("    useType: ").append(toIndentedString(useType)).append("\n");
    sb.append("    fsc: ").append(toIndentedString(fsc)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("to");
    openapiFields.add("from");
    openapiFields.add("description");
    openapiFields.add("metadata");
    openapiFields.add("mail_type");
    openapiFields.add("merge_variables");
    openapiFields.add("send_date");
    openapiFields.add("file");
    openapiFields.add("extra_service");
    openapiFields.add("cards");
    openapiFields.add("color");
    openapiFields.add("double_sided");
    openapiFields.add("address_placement");
    openapiFields.add("return_envelope");
    openapiFields.add("perforated_page");
    openapiFields.add("custom_envelope");
    openapiFields.add("billing_group_id");
    openapiFields.add("qr_code");
    openapiFields.add("use_type");
    openapiFields.add("fsc");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("to");
    openapiRequiredFields.add("from");
    openapiRequiredFields.add("file");
    openapiRequiredFields.add("color");
    openapiRequiredFields.add("use_type");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to LetterEditable
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LetterEditable.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LetterEditable is not found in the empty JSON string", LetterEditable.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LetterEditable.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LetterEditable` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : LetterEditable.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `to`
      InputToTo.validateJsonElement(jsonObj.get("to"));
      // validate the required field `from`
      InputFromFrom.validateJsonElement(jsonObj.get("from"));
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // validate the optional field `mail_type`
      if (jsonObj.get("mail_type") != null && !jsonObj.get("mail_type").isJsonNull()) {
        MailType.validateJsonElement(jsonObj.get("mail_type"));
      }
      // validate the optional field `send_date`
      if (jsonObj.get("send_date") != null && !jsonObj.get("send_date").isJsonNull()) {
        SendDate.validateJsonElement(jsonObj.get("send_date"));
      }
      // validate the required field `file`
      LtrFile.validateJsonElement(jsonObj.get("file"));
      // validate the optional field `extra_service`
      if (jsonObj.get("extra_service") != null && !jsonObj.get("extra_service").isJsonNull()) {
        ExtraService.validateJsonElement(jsonObj.get("extra_service"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("cards") != null && !jsonObj.get("cards").isJsonNull() && !jsonObj.get("cards").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `cards` to be an array in the JSON string but got `%s`", jsonObj.get("cards").toString()));
      }
      // validate the required field `color`
      Boolean.validateJsonElement(jsonObj.get("color"));
      // validate the optional field `address_placement`
      if (jsonObj.get("address_placement") != null && !jsonObj.get("address_placement").isJsonNull()) {
        AddressPlacement.validateJsonElement(jsonObj.get("address_placement"));
      }
      // validate the optional field `return_envelope`
      if (jsonObj.get("return_envelope") != null && !jsonObj.get("return_envelope").isJsonNull()) {
        ReturnEnvelopeUserProvided.validateJsonElement(jsonObj.get("return_envelope"));
      }
      if ((jsonObj.get("custom_envelope") != null && !jsonObj.get("custom_envelope").isJsonNull()) && !jsonObj.get("custom_envelope").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `custom_envelope` to be a primitive type in the JSON string but got `%s`", jsonObj.get("custom_envelope").toString()));
      }
      if ((jsonObj.get("billing_group_id") != null && !jsonObj.get("billing_group_id").isJsonNull()) && !jsonObj.get("billing_group_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `billing_group_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("billing_group_id").toString()));
      }
      // validate the optional field `qr_code`
      if (jsonObj.get("qr_code") != null && !jsonObj.get("qr_code").isJsonNull()) {
        QrCode.validateJsonElement(jsonObj.get("qr_code"));
      }
      // validate the required field `use_type`
      LtrUseType.validateJsonElement(jsonObj.get("use_type"));
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LetterEditable.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LetterEditable' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LetterEditable> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LetterEditable.class));

       return (TypeAdapter<T>) new TypeAdapter<LetterEditable>() {
           @Override
           public void write(JsonWriter out, LetterEditable value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LetterEditable read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of LetterEditable given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of LetterEditable
  * @throws IOException if the JSON string is invalid with respect to LetterEditable
  */
  public static LetterEditable fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LetterEditable.class);
  }

 /**
  * Convert an instance of LetterEditable to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

